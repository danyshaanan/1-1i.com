<!DOCTYPE html>
<html lang=en>
<head>
<title>Dany Shaanan - L-systems</title>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
<meta name='googlebot' content='noarchive' />
<meta name='robots'    content='noarchive, nosnippet' />
<meta name='description' content='L-Systems fractals - An HTML5 Canvas page by Dany Shaanan' />
<style>
body { margin: 0px; padding: 0px; color: white; }
canvas { position:absolute; left: 0px; top: 0px; cursor: pointer; }
span#move { position:absolute; left: 10px; top: 10px; color: black;}
span#click { position:absolute; left: 10px; top: 30px; }
span#credit { position:absolute; right: 10px; bottom: 10px; color: #888; }
span { margin: 6px; }
</style>
</head>
<body>

<canvas id='canvas'><div>Sorry, but your browser does not support the Canvas element!</div></canvas>
<span id='credit'>Created by <a href='/'>Dany Shaanan</a>, Dec 2014.<br /></span>
<span id='move'>Move the cursor.</span>
<span id='click'>Click to replace pattern.<br />Right click to toggle animation.</span>

<script>
'use strict'

function CanvasMouseAnimation(selector, frame) {
  this.canvas = document.querySelector(selector)
  if (!this.canvas) throw new Error('selector "' + selector + '" not found!')
  this.ctx = this.canvas.getContext && this.canvas.getContext('2d')
  if (!this.ctx) throw new Error('ctx not found! Is element a canvas?')
  this.setSize = function() {
    this.canvas.width = document.documentElement.clientWidth
    this.canvas.height = document.documentElement.clientHeight
  }
  this.frame = function() {
    frame(this.ctx, this.mouse && this.mouse.x, this.mouse && this.mouse.y)
    window.requestAnimationFrame(this.frame.bind(this))
  }
  window.onmousemove = function(event) {
    if (!this.mouse) {
      this.mouse = {}
      window.onmousemove(event)

    }
    this.mouse.x = event.x
    this.mouse.y = event.y
  }.bind(this)
  window.onload = window.onresize = this.setSize.bind(this)
  this.frame()
}

// function Timer() {
//   var start = Date.now()
//   this.end = function() {
//     var end = Date.now()
//     console.log((end - start)/1000)
//   }
// }

function getFracSequence(frac) {
  if (!frac.sequence) {
    frac.regex = new RegExp(Object.keys(frac.dict).join('|'), 'g')
    frac.sequence = frac.start
    while (frac.sequence.replace(/[\-+rlRL]/g,'').length < 1000) {
      frac.sequence = frac.sequence.replace(frac.regex, function(word) { return frac.dict[word] })
    }
  }
  return frac.sequence
}

function calcSequenceAtAngle(sequence, angle) {
  var direction = 0
  var path = [{ x: 0, y: 0 }]
  var actions = {
    '+': function() { direction += angle },
    '-': function() { direction -= angle },
    'l': function() { direction += Math.PI*2/4 },
    'r': function() { direction -= Math.PI*2/4 },
    'L': function() { direction += Math.PI*2/6 },
    'R': function() { direction -= Math.PI*2/6 },
    'y': function() {},
    'x': function() {},
    'f': function() {
      path.push({
        x: path[path.length - 1].x + Math.cos(direction),
        y: path[path.length - 1].y + Math.sin(direction)
      })
    }
  }
  sequence.split('').forEach(function(char) {
    (actions[char] || actions.f)()
  })
  return path
}

function fitPath(path, width, height) {
  function linear(value, x1, x2, y1, y2) {
    return (value - x1)*((y2 - y1)/(x2 - x1)) + y1
  }
  var xs = path.map(function(v){return v.x})
  var ys = path.map(function(v){return v.y})
  var max = { x: Math.max.apply(null, xs), y: Math.max.apply(null, ys) }
  var min = { x: Math.min.apply(null, xs), y: Math.min.apply(null, ys) }
  var size = { x: max.x - min.x, y: max.y - min.y }
  var ratio = Math.min(width / size.x, height / size.y)
  var finalSize = { x: size.x * ratio, y: size.y * ratio }
  var margin = { x: (width - finalSize.x) / 2, y: (height - finalSize.y) / 2}
  path = path.map(function(v) {
    return {
      x: linear(v.x, min.x, max.x, margin.x + 20, finalSize.x + margin.x - 20),
      y: linear(v.y, min.y, max.y, margin.y + 20, finalSize.y + margin.y - 20)
    }
  })
  return path
}

function drawPath(path, ctx) {
  ctx.beginPath()
  path.forEach(function(v) {
    ctx.lineTo(v.x, v.y)
  })
  ctx.stroke()
}


////////////////////////////////////////////////////////////////////////////////

function tauBy(n) {
  return Math.PI * 2 / n
}

var fracs = [
  { angle: tauBy(6), start: 'a',         dict: { a: '-b+a+b-', b: '+a-b-a+' }          }, //Sierpinski triangle
  { angle: tauBy(6), start: 'frfrfrfr',  dict: { f: 'f-f++f-f' }                       }, //square Koch
  { angle: tauBy(4), start: 'frfrfrf',   dict: { f: 'ff+f-f-f+ff'},                    }, //21112
  { angle: tauBy(6), start: 'fRRfRRfRR', dict: { f: 'f+f--f+f' }                       }, //Koch
  { angle: tauBy(4), start: 'frfrfrfr',  dict: { f: 'f+f-f-f+f' }                      }, //right angle Koch
  { angle: tauBy(4), start: 'qrqrqrq',   dict: { q: '+pf-qfq-fp+', p: '-qf+pfp+fq-'},  }, //hilbert
  { angle: tauBy(4), start: 'frfrfrf',   dict: { f: 'f+f-f-ff+f+f-f'},                 }, //swirle
  { angle: tauBy(4), start: 'ararara',   dict: { a: 'a+a-b-a+a', b: 'a-a+b+a-a'},      }, //antena
  { angle: tauBy(4), start: 'fx',        dict: { x: 'x+yf', y: 'fx-y' }                }, //dragon curve
  { angle: tauBy(8), start: 'a',         dict: { a: 'a+f+b', b: 'a-f-b'},              }, //non intersec Dragon
  { angle: tauBy(4), start: 'f',         dict: { f: '+f-ff-f+'},                       }, //shell
  { angle: tauBy(2), start: 'f',         dict: { f: 'a+ff' }                           }, //?
]

var id = 0
var lastCursor
var auto = true
var clearScreen = true

////////////////////////////////////////////////////////////////////////////////

window.onclick = function(event) {
  if (!id) [].forEach.call(document.querySelectorAll('span'),function(o){ o.innerHTML = '' })
  if (event.button === 0) id++ //left click
  if (event.button === 1) clearScreen ^= true //middle click
}

window.oncontextmenu = function() {
  auto ^= true
  return false
}

var canvasMouseAnimation = new CanvasMouseAnimation('#canvas', function(ctx, x, y) {
  var cursor = { x: x, y: y }
  if (!auto && lastCursor && lastCursor.x === cursor.x && lastCursor.y === cursor.y) return
  lastCursor = cursor

  var mod = { x: cursor.x / ctx.canvas.width, y: cursor.y / ctx.canvas.height }
  var frac = fracs[id % fracs.length]
  var angle = frac.angle + (auto ? Date.now() / 7000 : 2*Math.PI * (mod.x - 0.5))
  var sequence = getFracSequence(frac)
  var path = fitPath(calcSequenceAtAngle(sequence, angle), ctx.canvas.width, ctx.canvas.height)

  ctx.fillStyle = '#000'
  if (clearScreen) ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
  ctx.strokeStyle = 'hsl(' + parseInt((mod.y || 0) * 360) + ',100%, 50%)'
  drawPath(path, ctx)
})





</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-37601688-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
